SELECT * FROM EMPLOYEES;

/* 상품(PRODUCT) 테이블을 생성한다.
 * 제약조건 PK를 설정한다.
 * 
 * - 상품번호
 * - 이름
 * - 가격
 */
 CREATE TABLE TBL_PRODUCT(
 	PRODUCT_NUMBER NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
 	PRODUCT_NAME VARCHAR2(1000),
 	PRODUCT_PRICE NUMBER
 );
SELECT * FROM TBL_PRODUCT; 

INSERT INTO TBL_PRODUCT 
VALUES(1, '갤럭시 S23 ULTRA', 10000);

INSERT INTO TBL_PRODUCT 
VALUES(1, '갤럭시 S23 ULTRA', 10000); -- 오류 : 상품번호 PK 중복을 허용하지 않는다.

INSERT INTO TBL_PRODUCT 
VALUES(2, '갤럭시 S23 ULTRA', 10000);

INSERT INTO TBL_PRODUCT 
VALUES(NULL, '갤럭시 워치', 5000); -- 오류 : 상품번호 PK NULL을 허용하지 않는다.

--==============================================================
-- FK
CREATE TABLE TBL_SCHOOL(
	SCHOOL_NUMBER NUMBER,
	SCHOOL_NAME VARCHAR2(1000),
	CONSTRAINT PK_SCHOOL PRIMARY KEY(SCHOOL_NUMBER)
);
DROP TABLE TBL_STUDENT;

CREATE TABLE TBL_STUDENT(
	STUDENT_NUMBER NUMBER,
	STUDENT_NAME VARCHAR2(1000),
	STUDENT_AGE NUMBER,
    SCHOOL_NUMBER NUMBER,
    CONSTRAINT PK_STUDENT PRIMARY KEY(STUDENT_NUMBER),
    CONSTRAINT FK_STUDENT FOREIGN KEY(SCHOOL_NUMBER)
    REFERENCES TBL_SCHOOL(SCHOOL_NUMBER)
);

INSERT INTO TBL_SCHOOL 
VALUES(1, '호근대학교');

INSERT INTO TBL_SCHOOL
VALUES(2, '들갑대학교');

INSERT INTO TBL_SCHOOL
VALUES(3, '포근대학교');

SELECT * FROM TBL_SCHOOL;

INSERT INTO TBL_STUDENT 
VALUES(1, '김철수', 17, 5); -- 오류 발생! FK인 SCHOOL_NUMBER 에 존재하지 않는 값을 저장하려함.

INSERT INTO TBL_STUDENT
VALUES(1, '김철수', 17, 1);

INSERT INTO TBL_STUDENT
VALUES(2, '신짱구', 17, 1);

INSERT INTO TBL_STUDENT
VALUES(3, '이유리', 17, 2);

INSERT INTO TBL_STUDENT 
VALUES(4, '훈이', 17, 2);

SELECT * FROM TBL_STUDENT;
DROP TABLE TBL_STUDENT;
--=============================================================================
/* 학생 테이블 생성
 * - 학생 번호
 * - 학생 ID
 * - 학생 이름
 * - 전공
 * - 성별
 */
 CREATE TABLE TBL_STUDENT(
 	STUDENT_NUMBER NUMBER CONSTRAINT PK_STUDENT PRIMARY KEY,
 	STUDENT_ID VARCHAR2(1000) CONSTRAINT UK_STUDENT UNIQUE, -- UNIQUE 는 KEY를 붙이지 않아도 된다.
 	STUDENT_NAME VARCHAR2(1000),
 	STUDENT_MAJOR VARCHAR2(1000),
 	STUDENT_GENDER CHAR(1) -- GENDER는 'M' 또는 'W'만 저장할 것이므로 고정크기 1로 한다.
 );
 
 CREATE TABLE TBL_STUDENT(
 	STUDENT_NUMBER NUMBER CONSTRAINT PK_STUDENT PRIMARY KEY,
 	STUDENT_ID VARCHAR2(1000) CONSTRAINT UK_STUDENT UNIQUE, -- UNIQUE 는 KEY를 붙이지 않아도 된다.
 	STUDENT_NAME VARCHAR2(1000),
 	STUDENT_MAJOR VARCHAR2(1000),
 	STUDENT_GENDER CHAR(1) DEFAULT 'W' NOT NULL CHECK(STUDENT_GENDER = 'M' OR STUDENT_GENDER = 'W')
 );
-- DEFAULT 'W' 는 데이터가 들어오지 않으면 무조건 'W'가 기본으로 들어가게 해준다.
-- 디폴트 값을 W로 설정했으니 NULL 값을 강제로 넣는 것을 막아주는 게 좋을 것이다.
-- 이럴 때 사용하는 게 NOT NULL 이라는 제약조건이다.
-- 그리고 마지막으로 이 컬럼에 'M' 또는 'W'만 들어오게 하는 제약조건을 걸어줘야 한다.
-- 저장되려는 값이 'M' 또는 'W'인지 검사해야 한다.(체크)

INSERT INTO TBL_STUDENT 
VALUES(1, 'AA', '철수', '컴공', 'M');

INSERT INTO TBL_STUDENT 
VALUES(2, 'AA', '유리', '전기', 'W');

INSERT INTO TBL_STUDENT 
VALUES(2, 'BB', '유리', '전기', 'W');

INSERT INTO TBL_STUDENT
(STUDENT_NUMBER, STUDENT_ID, STUDENT_NAME, STUDENT_MAJOR)
VALUES(3, 'CC', '영희', '전자');
-- 성별을 생략하면 디폴트 값인 W가 들어간다.
SELECT * FROM TBL_STUDENT;

INSERT INTO TBL_STUDENT 
VALUES(4, 'DD', '호근', '컴공', 'G'); -- CHECK 제약조건에서 오류!
--===============================================================
-- 조합키
CREATE TABLE TBL_FLOWER(
	FLOWER_NAME VARCHAR2(1000),
	FLOWER_COLOR VARCHAR2(1000),
	FLOWER_PRICE NUMBER,
	CONSTRAINT PK_FLOWER PRIMARY KEY(FLOWER_NAME, FLOWER_COLOR)
);

INSERT INTO TBL_FLOWER
VALUES('장미', '빨강', 1000);

INSERT INTO TBL_FLOWER
VALUES('장미', '파랑', 2000);

INSERT INTO TBL_FLOWER
VALUES('장미', '빨강', 3000); -- 오류 조합키 2개의 컬럼이 모두 일치함.
--===============================================================
-- 모델링 예제 [구현]
CREATE TABLE TBL_PHONE(
	PHONE_SERIAL_NUMBER VARCHAR2(1000) CONSTRAINT PK_PHONE PRIMARY KEY,
	PHONE_COLOR VARCHAR2(1000),
	PHONE_SIZE NUMBER,
	PHONE_PRICE NUMBER,
	PHONE_PRODUCTION_DATE DATE,
	PHONE_SALE NUMBER
);

CREATE TABLE TBL_CASE(
	CASE_SERIAL_NUMBER VARCHAR2(1000),
	CASE_COLOR VARCHAR2(1000),
	CASE_PRICE NUMBER,		
	PHONE_SERIAL_NUMBER VARCHAR2(1000),
	CONSTRAINT PK_CASE PRIMARY KEY(CASE_SERIAL_NUMBER),
	CONSTRAINT FK_CASE FOREIGN KEY(PHONE_SERIAL_NUMBER)
	REFERENCES TBL_PHONE(PHONE_SERIAL_NUMBER)
);

--=================================================================
-- 모델링 실습 (구현)
DROP TABLE TBL_MEMBER;
CREATE TABLE TBL_MEMBER(
	MEMBER_NUMBER NUMBER,
	MEMBER_NAME VARCHAR2(1000),
	MEMBER_AGE NUMBER,
	MEMBER_PHONE_NUMBER VARCHAR2(1000) NOT NULL,
	MEMBER_ADDRESS VARCHAR2(1000) NOT NULL,
	CONSTRAINT PK_MEMBER PRIMARY KEY(MEMBER_NUMBER),
	CONSTRAINT UK_MEMBER UNIQUE(MEMBER_PHONE_NUMBER)
);

CREATE TABLE TBL_BOOK(
	BOOK_NUMBER NUMBER,
	BOOK_NAME VARCHAR2(1000) NOT NULL,
	BOOK_CATEGORY VARCHAR2(1000),
	MEMBER_NUMBER NUMBER,
	CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_NUMBER),
	CONSTRAINT CHECK_CATEGORY
	CHECK(
		BOOK_CATEGORY = '인문학' OR
		BOOK_CATEGORY = '추리' OR 
		BOOK_CATEGORY = 'IT' OR 
		BOOK_CATEGORY = '로맨스'
	),
	CONSTRAINT FK_BOOK FOREIGN KEY(MEMBER_NUMBER)
	REFERENCES TBL_MEMBER(MEMBER_NUMBER)
);
--=======================================================================
-- 관계를 맺은 테이블들의 DML
SELECT * FROM TBL_PHONE;
SELECT * FROM TBL_CASE;

INSERT INTO TBL_PHONE
(PHONE_SERIAL_NUMBER, PHONE_COLOR, PHONE_SIZE, PHONE_PRICE, PHONE_PRODUCTION_DATE)
VALUES('S23-001', 'GREEN', 7, 10000, '2023-03-26');
-- DATE타입의 컬럼에 문자타입의 값을 'YYYY-MM-DD'의 형태로 넣으면
-- 자동으로 DATE타입으로 변환되어 들어간다.

INSERT INTO TBL_PHONE
(PHONE_SERIAL_NUMBER, PHONE_COLOR, PHONE_SIZE, PHONE_PRICE, PHONE_PRODUCTION_DATE)
VALUES('S23-002', 'BLACK', 7, 10000, SYSDATE - 10);

INSERT INTO TBL_PHONE
(PHONE_SERIAL_NUMBER, PHONE_COLOR, PHONE_SIZE, PHONE_PRICE, PHONE_PRODUCTION_DATE)
VALUES('S23-003', 'RED', 7, 10000, TO_DATE('2023-02-16'));
-- TO_DATE() 함수를 이용하여 문자열을 직접 DATE 타입으로 바꿀 수도 있다.

-- 자식테이블 INSERT 
INSERT INTO TBL_CASE 
VALUES('A', 'WHITE', 1000, 'S23-001');

INSERT INTO TBL_CASE 
VALUES('B', 'WHITE', 1000, 'S23-002');

-- 관계를 맺은 테이블 UPDATE 
UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S23-004'
WHERE PHONE_SERIAL_NUMBER = 'S23-002';

/* 자식에서 부모테이블의 값을 참조중인 경우 부모테이블의 값을 수정할 수 없다.
 * 이럴 경우 자식에서 참조중인 데이터를 다른 값으로 바꾸거나
 * NULL로 변경하고 수정한다.
 */
 
-- 1.
-- 참조중인 값을 NULL로 변경 후 수정
-- 정말 급한 게 아니면 비추천
UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = NULL 
WHERE PHONE_SERIAL_NUMBER = 'S23-002';

UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S23-004'
WHERE PHONE_SERIAL_NUMBER = 'S23-002';

UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = 'S23-004'
WHERE PHONE_SERIAL_NUMBER IS NULL;

SELECT * FROM TBL_CASE;

-- 2.
-- 참조중인 값을 다른 값으로 변경 후 수정
-- 자식의 FK를 변경할 때에는 부모에 존재하는 값으로 변경해야 한다.
UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = 'S23-004'
WHERE CASE_SERIAL_NUMBER = 'A';

UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S23-005'
WHERE PHONE_SERIAL_NUMBER = 'S23-001';

UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = 'S23-005'
WHERE CASE_SERIAL_NUMBER = 'A';

SELECT * FROM TBL_CASE;

-- 3.
-- 만약 부모에 없는 값으로 변경하려면 부모에 먼저 INSERT 하고
-- 자식 FK를 수정한다.

/* 부모 테이블에서 데이터 삭제하기 */